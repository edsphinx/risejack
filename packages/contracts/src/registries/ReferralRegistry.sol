// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.28;

/* --------------------------------------------------------------------------
 * REFERRALREGISTRY â€” MULTI-TIER REFERRAL REWARD SYSTEM
 * -------------------------------------------------------------------------
 * Tracks referral relationships and distributes house edge share to referrers.
 *
 * - Level 1 (Direct): 50% of referral share to direct referrer
 * - Level 2 (Indirect): 10% of referral share to referrer's referrer
 * - Claim System: Referrers can claim accumulated earnings anytime
 * - Volume Tracking: Tracks total volume generated by each referrer
 * ------------------------------------------------------------------------*/

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/// @notice Interface for VyreTreasury payouts
interface IVyreTreasury {
    function payout(
        address to,
        address token,
        uint256 amount
    ) external;
}

/**
 * @title  ReferralRegistry
 * @author edsphinx
 * @custom:company Blocketh
 * @notice Multi-tier referral system with claimable earnings.
 * @dev    Example: Player A refers B, B refers C
 *         When C plays with 100 CHIP house edge:
 *         - B (direct) gets 50 CHIP
 *         - A (indirect) gets 10 CHIP
 */
contract ReferralRegistry is ReentrancyGuard {
    using SafeERC20 for IERC20;

    // ----------------------------------------------------------------------
    //  STORAGE
    // ----------------------------------------------------------------------

    /// @notice Owner (can update settings)
    address public owner;

    /// @notice Treasury for payouts
    IVyreTreasury public treasury;

    /// @notice Authorized callers (VyreCasino)
    mapping(address => bool) public authorizedCallers;

    /// @notice Direct referrer for each player
    mapping(address => address) public referrers;

    /// @notice Whether player has set a referrer
    mapping(address => bool) public hasReferrer;

    /// @notice Accumulated earnings per referrer per token
    mapping(address => mapping(address => uint256)) public earnings;

    /// @notice Total earnings claimed
    mapping(address => mapping(address => uint256)) public claimedEarnings;

    /// @notice Total players referred (direct)
    mapping(address => uint256) public totalReferred;

    /// @notice Total volume generated by referrals
    mapping(address => mapping(address => uint256)) public referralVolume;

    // ==================== CONFIG ====================

    /// @notice Level 1 (direct) share in bps (5000 = 50%)
    uint256 public directShareBps = 5000;

    /// @notice Level 2 (indirect) share in bps (1000 = 10%)
    uint256 public indirectShareBps = 1000;

    /// @notice Self-referral allowed (for testing)
    bool public selfReferralAllowed = false;

    // ==================== EVENTS ====================

    event ReferrerSet(address indexed player, address indexed referrer);
    event EarningsRecorded(
        address indexed referrer,
        address indexed player,
        address indexed token,
        uint256 amount,
        uint8 level
    );
    event EarningsClaimed(address indexed referrer, address indexed token, uint256 amount);

    // ==================== MODIFIERS ====================

    modifier onlyOwner() {
        require(msg.sender == owner, "ReferralRegistry: only owner");
        _;
    }

    modifier onlyAuthorized() {
        require(authorizedCallers[msg.sender], "ReferralRegistry: not authorized");
        _;
    }

    // ==================== CONSTRUCTOR ====================

    constructor(
        address _owner,
        address _treasury
    ) {
        require(_owner != address(0), "ReferralRegistry: zero owner");
        require(_treasury != address(0), "ReferralRegistry: zero treasury");
        owner = _owner;
        treasury = IVyreTreasury(_treasury);
    }

    // ==================== PLAYER FUNCTIONS ====================

    /**
     * @notice Set referrer for caller
     * @param referrer Referrer address
     */
    function setReferrer(
        address referrer
    ) external {
        require(!hasReferrer[msg.sender], "ReferralRegistry: referrer already set");
        require(referrer != address(0), "ReferralRegistry: zero referrer");

        if (!selfReferralAllowed) {
            require(referrer != msg.sender, "ReferralRegistry: self referral");
        }

        referrers[msg.sender] = referrer;
        hasReferrer[msg.sender] = true;
        totalReferred[referrer]++;

        emit ReferrerSet(msg.sender, referrer);
    }

    /**
     * @notice Claim accumulated earnings
     * @param token Token to claim
     */
    function claimEarnings(
        address token
    ) external nonReentrant {
        uint256 amount = earnings[msg.sender][token];
        require(amount > 0, "ReferralRegistry: no earnings");

        earnings[msg.sender][token] = 0;
        claimedEarnings[msg.sender][token] += amount;

        treasury.payout(msg.sender, token, amount);

        emit EarningsClaimed(msg.sender, token, amount);
    }

    // ==================== GAME FUNCTIONS (AUTHORIZED) ====================

    /**
     * @notice Record referral earnings from a game
     * @param player Player who generated the earnings
     * @param token Token type
     * @param houseEdgeAmount Total house edge from this play
     * @param betAmount Bet amount for volume tracking
     */
    function recordEarnings(
        address player,
        address token,
        uint256 houseEdgeAmount,
        uint256 betAmount
    ) external onlyAuthorized {
        if (!hasReferrer[player]) return;

        // Level 1: Direct referrer
        address level1 = referrers[player];
        if (level1 != address(0)) {
            uint256 level1Amount = (houseEdgeAmount * directShareBps) / 10_000;
            if (level1Amount > 0) {
                earnings[level1][token] += level1Amount;
                referralVolume[level1][token] += betAmount;
                emit EarningsRecorded(level1, player, token, level1Amount, 1);
            }

            // Level 2: Indirect referrer (referrer's referrer)
            address level2 = referrers[level1];
            if (level2 != address(0)) {
                uint256 level2Amount = (houseEdgeAmount * indirectShareBps) / 10_000;
                if (level2Amount > 0) {
                    earnings[level2][token] += level2Amount;
                    emit EarningsRecorded(level2, player, token, level2Amount, 2);
                }
            }
        }
    }

    // ==================== VIEW FUNCTIONS ====================

    /**
     * @notice Get referral tree for a player
     * @return level1 Direct referrer
     * @return level2 Indirect referrer
     */
    function getReferralTree(
        address player
    ) external view returns (address level1, address level2) {
        level1 = referrers[player];
        if (level1 != address(0)) {
            level2 = referrers[level1];
        }
    }

    /**
     * @notice Get pending earnings
     */
    function pendingEarnings(
        address referrer,
        address token
    ) external view returns (uint256) {
        return earnings[referrer][token];
    }

    /**
     * @notice Get referrer stats
     */
    function getReferrerStats(
        address referrer,
        address token
    )
        external
        view
        returns (
            uint256 _totalReferred,
            uint256 _totalVolume,
            uint256 _totalEarned,
            uint256 _pendingEarnings
        )
    {
        _totalReferred = totalReferred[referrer];
        _totalVolume = referralVolume[referrer][token];
        _totalEarned = claimedEarnings[referrer][token];
        _pendingEarnings = earnings[referrer][token];
    }

    // ==================== ADMIN FUNCTIONS ====================

    function authorizeCaller(
        address caller
    ) external onlyOwner {
        require(caller != address(0), "ReferralRegistry: zero caller");
        authorizedCallers[caller] = true;
    }

    function revokeCaller(
        address caller
    ) external onlyOwner {
        authorizedCallers[caller] = false;
    }

    function setShares(
        uint256 _directBps,
        uint256 _indirectBps
    ) external onlyOwner {
        require(_directBps + _indirectBps <= 10_000, "ReferralRegistry: shares exceed 100%");
        directShareBps = _directBps;
        indirectShareBps = _indirectBps;
    }

    function setTreasury(
        address _treasury
    ) external onlyOwner {
        require(_treasury != address(0), "ReferralRegistry: zero treasury");
        treasury = IVyreTreasury(_treasury);
    }

    function setSelfReferralAllowed(
        bool allowed
    ) external onlyOwner {
        selfReferralAllowed = allowed;
    }

    function transferOwnership(
        address newOwner
    ) external onlyOwner {
        require(newOwner != address(0), "ReferralRegistry: zero owner");
        owner = newOwner;
    }
}
